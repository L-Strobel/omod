package de.uniwuerzburg.omod

import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.parameters.arguments.argument
import com.github.ajalt.clikt.parameters.groups.default
import com.github.ajalt.clikt.parameters.groups.mutuallyExclusiveOptions
import com.github.ajalt.clikt.parameters.groups.single
import com.github.ajalt.clikt.parameters.options.convert
import com.github.ajalt.clikt.parameters.options.default
import com.github.ajalt.clikt.parameters.options.option
import com.github.ajalt.clikt.parameters.types.*
import de.uniwuerzburg.omod.core.Omod
import de.uniwuerzburg.omod.core.logger
import de.uniwuerzburg.omod.core.models.AssignmentOption
import de.uniwuerzburg.omod.core.models.ModeChoiceOption
import de.uniwuerzburg.omod.core.models.Weekday
import de.uniwuerzburg.omod.io.formatOutput
import de.uniwuerzburg.omod.routing.RoutingMode
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.encodeToStream
import java.io.File
import java.io.FileOutputStream
import java.nio.file.Paths

sealed interface AgentNumberDefinition

class FixedAgentNumber(
    val value: Int
) : AgentNumberDefinition
class ShareOfPop (
    val value: Double
) : AgentNumberDefinition

/**
 * CLI interface
 */
@Suppress("PrivatePropertyName")
class Run : CliktCommand() {
    // Arguments
    private val area_geojson by argument(
        help = "Path to the GeoJSON file that defines the area for which you want to generate mobility demand. " +
                "Helpful websites for GeoJSON generation: https://geojson.io, https://polygons.openstreetmap.fr"
    ).file(mustExist = true, mustBeReadable = true)
    private val osm_file by argument(
        help = "Path to an osm.pbf file that covers the area completely. " +
               "Recommended download platform: https://download.geofabrik.de/"
    ).file(mustExist = true, mustBeReadable = true)
    // Options
    private val agentNumberDefinition by mutuallyExclusiveOptions(
        option(
            "--n_agents",
            help="Number of agents to simulate. " +
                 "If populate_buffer_area = y, additional agents are created to populate the buffer area."
        ).int().convert { FixedAgentNumber(it) },
        option(
            "--share_pop",
            help="Share of the population to simulate. 0.0 = 0%, 1.0 = 100%" +
                 " If populate_buffer_area = y, additional agents are created to populate the buffer area."
        ).double().convert { ShareOfPop(it) }
    ).single().default( FixedAgentNumber(1000) )
    private val n_days by option(
        help="Number of days to simulate"
    ).int().default(1)
    private val start_wd by option(
        help="First weekday to simulate. If the value is set to UNDEFINED, all simulated days will be UNDEFINED."
    ).enum<Weekday>().default(Weekday.UNDEFINED)
    private val out by option (
        help="Output file. Should end with '.json'"
    ).file().default(File("output.json"))
    private val routing_mode by option(
        help = "Distance calculation method for destination choice." +
               " Either euclidean distance (BEELINE) or routed distance by car (GRAPHHOPPER)"
    ).enum<RoutingMode>().default(RoutingMode.GRAPHHOPPER)
    private val od by option(
        help="[Experimental] Path to an OD-Matrix in GeoJSON format. " +
             "The matrix is used to further calibrate the model to the area using k-factors."
    ).file(mustExist = true, mustBeReadable = true)
    private val census by option(
        help="Path to population data in GeoJSON format. " +
             "For an example of how to create such a file see python_tools/format_zensus2011.py. " +
             "Should cover the entire area, but can cover more."
    ).file(mustExist = true, mustBeReadable = true)
    private val grid_precision by option(
        help="Allowed average distance between a focus area building and its corresponding TAZ center. " +
             "The default is 150m and suitable in most cases." +
             "In the buffer area the allowed distance increases quadratically with distance. " +
             "Unit: meters"
    ).double().default(150.0)
    private val buffer by option(
        help="Distance by which the focus area (defined by GeoJSON) is buffered in order" +
             " to account for traffic generated by the surrounding. Unit: meters"
    ).double().default(0.0)
    private val seed by option(help = "RNG seed.").long()
    private val cache_dir by option(help = "Cache directory")
        .path(canBeDir = true, canBeFile = false).default(Paths.get("omod_cache/"))
    private val populate_buffer_area by option(
        help = "Determines if home locations of agents can be in the buffer area (so outside of the focus area). " +
               "If set to 'y' additional agents will be created so that the proportion of agents in and " +
               "outside the focus area is the same as in the census data. " +
               "The focus area will always be populated by n_agents agents."
    ).choice( mapOf("y" to true, "n" to false), ignoreCase = true).default(false)
    private val distance_matrix_cache_size by option(
        help = "Maximum number of entries of the distance matrix to precompute (only if routing_mode is GRAPHHOPPER). " +
               "A high value will lead to high RAM usage and long initialization times " +
               "but overall significant speed gains. The default value will use approximately 8 GB RAM at maximum."
    ).long().default(400e6.toLong())
    private val mode_choice by option(
        help = "Type of mode choice. " +
               "NONE: Returns trips with undefined modes." +
               "GTFS: Uses a logit model with public transit as an option"
    ).choice(
        mapOf("NONE" to ModeChoiceOption.NONE, "GTFS" to ModeChoiceOption.GTFS
    ), ignoreCase = true).default(ModeChoiceOption.NONE)
    private val return_path_coords by option(
        help = "Whether lat/lon coordinates of chosen trip paths are returned." +
               "Paths only exist for trips with defined modes and within the focus area + buffer."
    ).choice( mapOf("y" to true, "n" to false), ignoreCase = true).default(false)
    private val population_file by option(
        help="Path to file that describes the socio-demographic makeup of the population. " +
             "Must be formatted like omod/src/main/resources/Population.json."
    ).file(mustExist = true, mustBeReadable = true)
    private val n_worker by option(
        help="Number of parallel coroutines that can be executed at the same time. " +
             "Default: Number of CPU-Cores available."
    ).int()

    @OptIn(ExperimentalSerializationApi::class)
    override fun run() {
        if ((census == null) && (agentNumberDefinition is ShareOfPop)) {
            throw Exception(
                "Agent population is supposed to be based on the population but no census file is provided." +
                "Consider adding a census file with --census or use --n_agents instead.")
        }

        // Init OMOD
        val omod = Omod(
            area_geojson, osm_file,
            mode = routing_mode,
            odFile = od, censusFile = census,
            gridPrecision = grid_precision, bufferRadius = buffer, seed = seed,
            cache = true, cacheDir = cache_dir,
            populateBufferArea = populate_buffer_area,
            distanceCacheSize = distance_matrix_cache_size,
            populationFile = population_file,
            nWorker = n_worker
        )

        // Mobility demand
        val agents = when (val aND = agentNumberDefinition ) {
            is FixedAgentNumber -> omod.run(aND.value, start_wd, n_days)
            is ShareOfPop -> omod.run(aND.value, start_wd, n_days)
        }

        // Mode Choice
        omod.doModeChoice(agents, mode_choice, return_path_coords)

        // Store output
        logger.info("Saving results...")
        FileOutputStream(out).use { f ->
            Json.encodeToStream( agents.map { formatOutput(it) }, f)
        }
        logger.info("Saving results... Done!")
    }
}

fun main(args: Array<String>) = Run().main(args)
